"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@borewit";
exports.ids = ["vendor-chunks/@borewit"];
exports.modules = {

/***/ "(rsc)/./node_modules/@borewit/text-codec/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@borewit/text-codec/lib/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   textDecode: () => (/* binding */ textDecode),\n/* harmony export */   textEncode: () => (/* binding */ textEncode)\n/* harmony export */ });\n// text-polyfill.ts\n// Minimal encode/decode for utf-8, utf-16le, ascii, latin1, windows-1252\nconst WINDOWS_1252_EXTRA = {\n    0x80: \"€\", 0x82: \"‚\", 0x83: \"ƒ\", 0x84: \"„\", 0x85: \"…\", 0x86: \"†\",\n    0x87: \"‡\", 0x88: \"ˆ\", 0x89: \"‰\", 0x8a: \"Š\", 0x8b: \"‹\", 0x8c: \"Œ\",\n    0x8e: \"Ž\", 0x91: \"‘\", 0x92: \"’\", 0x93: \"“\", 0x94: \"”\", 0x95: \"•\",\n    0x96: \"–\", 0x97: \"—\", 0x98: \"˜\", 0x99: \"™\", 0x9a: \"š\", 0x9b: \"›\",\n    0x9c: \"œ\", 0x9e: \"ž\", 0x9f: \"Ÿ\",\n};\nconst WINDOWS_1252_REVERSE = {};\nfor (const [code, char] of Object.entries(WINDOWS_1252_EXTRA)) {\n    WINDOWS_1252_REVERSE[char] = Number.parseInt(code);\n}\n/**\n * Decode text from binary data\n * @param bytes Binary data\n * @param encoding Encoding\n */\nfunction textDecode(bytes, encoding = \"utf-8\") {\n    switch (encoding.toLowerCase()) {\n        case \"utf-8\":\n        case \"utf8\":\n            if (typeof globalThis.TextDecoder !== \"undefined\") {\n                return new globalThis.TextDecoder(\"utf-8\").decode(bytes);\n            }\n            return decodeUTF8(bytes);\n        case \"utf-16le\":\n            return decodeUTF16LE(bytes);\n        case \"ascii\":\n            return decodeASCII(bytes);\n        case \"latin1\":\n        case \"iso-8859-1\":\n            return decodeLatin1(bytes);\n        case \"windows-1252\":\n            return decodeWindows1252(bytes);\n        default:\n            throw new RangeError(`Encoding '${encoding}' not supported`);\n    }\n}\nfunction textEncode(input = \"\", encoding = \"utf-8\") {\n    switch (encoding.toLowerCase()) {\n        case \"utf-8\":\n        case \"utf8\":\n            if (typeof globalThis.TextEncoder !== \"undefined\") {\n                return new globalThis.TextEncoder().encode(input);\n            }\n            return encodeUTF8(input);\n        case \"utf-16le\":\n            return encodeUTF16LE(input);\n        case \"ascii\":\n            return encodeASCII(input);\n        case \"latin1\":\n        case \"iso-8859-1\":\n            return encodeLatin1(input);\n        case \"windows-1252\":\n            return encodeWindows1252(input);\n        default:\n            throw new RangeError(`Encoding '${encoding}' not supported`);\n    }\n}\n// --- Internal helpers ---\nfunction decodeUTF8(bytes) {\n    let out = \"\";\n    let i = 0;\n    while (i < bytes.length) {\n        const b1 = bytes[i++];\n        if (b1 < 0x80) {\n            out += String.fromCharCode(b1);\n        }\n        else if (b1 < 0xe0) {\n            const b2 = bytes[i++] & 0x3f;\n            out += String.fromCharCode(((b1 & 0x1f) << 6) | b2);\n        }\n        else if (b1 < 0xf0) {\n            const b2 = bytes[i++] & 0x3f;\n            const b3 = bytes[i++] & 0x3f;\n            out += String.fromCharCode(((b1 & 0x0f) << 12) | (b2 << 6) | b3);\n        }\n        else {\n            const b2 = bytes[i++] & 0x3f;\n            const b3 = bytes[i++] & 0x3f;\n            const b4 = bytes[i++] & 0x3f;\n            let cp = ((b1 & 0x07) << 18) |\n                (b2 << 12) |\n                (b3 << 6) |\n                b4;\n            cp -= 0x10000;\n            out += String.fromCharCode(0xd800 + ((cp >> 10) & 0x3ff), 0xdc00 + (cp & 0x3ff));\n        }\n    }\n    return out;\n}\nfunction decodeUTF16LE(bytes) {\n    let out = \"\";\n    for (let i = 0; i < bytes.length; i += 2) {\n        out += String.fromCharCode(bytes[i] | (bytes[i + 1] << 8));\n    }\n    return out;\n}\nfunction decodeASCII(bytes) {\n    return String.fromCharCode(...bytes.map((b) => b & 0x7f));\n}\nfunction decodeLatin1(bytes) {\n    return String.fromCharCode(...bytes);\n}\nfunction decodeWindows1252(bytes) {\n    let out = \"\";\n    for (const b of bytes) {\n        if (b >= 0x80 && b <= 0x9f && WINDOWS_1252_EXTRA[b]) {\n            out += WINDOWS_1252_EXTRA[b];\n        }\n        else {\n            out += String.fromCharCode(b);\n        }\n    }\n    return out;\n}\nfunction encodeUTF8(str) {\n    const out = [];\n    for (let i = 0; i < str.length; i++) {\n        const cp = str.charCodeAt(i);\n        if (cp < 0x80) {\n            out.push(cp);\n        }\n        else if (cp < 0x800) {\n            out.push(0xc0 | (cp >> 6), 0x80 | (cp & 0x3f));\n        }\n        else if (cp < 0x10000) {\n            out.push(0xe0 | (cp >> 12), 0x80 | ((cp >> 6) & 0x3f), 0x80 | (cp & 0x3f));\n        }\n        else {\n            out.push(0xf0 | (cp >> 18), 0x80 | ((cp >> 12) & 0x3f), 0x80 | ((cp >> 6) & 0x3f), 0x80 | (cp & 0x3f));\n        }\n    }\n    return new Uint8Array(out);\n}\nfunction encodeUTF16LE(str) {\n    const out = new Uint8Array(str.length * 2);\n    for (let i = 0; i < str.length; i++) {\n        const code = str.charCodeAt(i);\n        out[i * 2] = code & 0xff;\n        out[i * 2 + 1] = code >> 8;\n    }\n    return out;\n}\nfunction encodeASCII(str) {\n    return new Uint8Array([...str].map((ch) => ch.charCodeAt(0) & 0x7f));\n}\nfunction encodeLatin1(str) {\n    return new Uint8Array([...str].map((ch) => ch.charCodeAt(0) & 0xff));\n}\nfunction encodeWindows1252(str) {\n    return new Uint8Array([...str].map((ch) => {\n        const code = ch.charCodeAt(0);\n        if (code <= 0xff)\n            return code;\n        if (WINDOWS_1252_REVERSE[ch] !== undefined)\n            return WINDOWS_1252_REVERSE[ch];\n        return 0x3f; // '?'\n    }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGJvcmV3aXQvdGV4dC1jb2RlYy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3JkZXItbWFuYWdlbWVudC1zeXN0ZW0vLi9ub2RlX21vZHVsZXMvQGJvcmV3aXQvdGV4dC1jb2RlYy9saWIvaW5kZXguanM/YmNkYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0ZXh0LXBvbHlmaWxsLnRzXG4vLyBNaW5pbWFsIGVuY29kZS9kZWNvZGUgZm9yIHV0Zi04LCB1dGYtMTZsZSwgYXNjaWksIGxhdGluMSwgd2luZG93cy0xMjUyXG5jb25zdCBXSU5ET1dTXzEyNTJfRVhUUkEgPSB7XG4gICAgMHg4MDogXCLigqxcIiwgMHg4MjogXCLigJpcIiwgMHg4MzogXCLGklwiLCAweDg0OiBcIuKAnlwiLCAweDg1OiBcIuKAplwiLCAweDg2OiBcIuKAoFwiLFxuICAgIDB4ODc6IFwi4oChXCIsIDB4ODg6IFwiy4ZcIiwgMHg4OTogXCLigLBcIiwgMHg4YTogXCLFoFwiLCAweDhiOiBcIuKAuVwiLCAweDhjOiBcIsWSXCIsXG4gICAgMHg4ZTogXCLFvVwiLCAweDkxOiBcIuKAmFwiLCAweDkyOiBcIuKAmVwiLCAweDkzOiBcIuKAnFwiLCAweDk0OiBcIuKAnVwiLCAweDk1OiBcIuKAolwiLFxuICAgIDB4OTY6IFwi4oCTXCIsIDB4OTc6IFwi4oCUXCIsIDB4OTg6IFwiy5xcIiwgMHg5OTogXCLihKJcIiwgMHg5YTogXCLFoVwiLCAweDliOiBcIuKAulwiLFxuICAgIDB4OWM6IFwixZNcIiwgMHg5ZTogXCLFvlwiLCAweDlmOiBcIsW4XCIsXG59O1xuY29uc3QgV0lORE9XU18xMjUyX1JFVkVSU0UgPSB7fTtcbmZvciAoY29uc3QgW2NvZGUsIGNoYXJdIG9mIE9iamVjdC5lbnRyaWVzKFdJTkRPV1NfMTI1Ml9FWFRSQSkpIHtcbiAgICBXSU5ET1dTXzEyNTJfUkVWRVJTRVtjaGFyXSA9IE51bWJlci5wYXJzZUludChjb2RlKTtcbn1cbi8qKlxuICogRGVjb2RlIHRleHQgZnJvbSBiaW5hcnkgZGF0YVxuICogQHBhcmFtIGJ5dGVzIEJpbmFyeSBkYXRhXG4gKiBAcGFyYW0gZW5jb2RpbmcgRW5jb2RpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHREZWNvZGUoYnl0ZXMsIGVuY29kaW5nID0gXCJ1dGYtOFwiKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgXCJ1dGYtOFwiOlxuICAgICAgICBjYXNlIFwidXRmOFwiOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLlRleHREZWNvZGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWxUaGlzLlRleHREZWNvZGVyKFwidXRmLThcIikuZGVjb2RlKGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVVVEY4KGJ5dGVzKTtcbiAgICAgICAgY2FzZSBcInV0Zi0xNmxlXCI6XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlVVRGMTZMRShieXRlcyk7XG4gICAgICAgIGNhc2UgXCJhc2NpaVwiOlxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZUFTQ0lJKGJ5dGVzKTtcbiAgICAgICAgY2FzZSBcImxhdGluMVwiOlxuICAgICAgICBjYXNlIFwiaXNvLTg4NTktMVwiOlxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZUxhdGluMShieXRlcyk7XG4gICAgICAgIGNhc2UgXCJ3aW5kb3dzLTEyNTJcIjpcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVXaW5kb3dzMTI1MihieXRlcyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRW5jb2RpbmcgJyR7ZW5jb2Rpbmd9JyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHRleHRFbmNvZGUoaW5wdXQgPSBcIlwiLCBlbmNvZGluZyA9IFwidXRmLThcIikge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlIFwidXRmLThcIjpcbiAgICAgICAgY2FzZSBcInV0ZjhcIjpcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5UZXh0RW5jb2RlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZ2xvYmFsVGhpcy5UZXh0RW5jb2RlcigpLmVuY29kZShpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlVVRGOChpbnB1dCk7XG4gICAgICAgIGNhc2UgXCJ1dGYtMTZsZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGVuY29kZVVURjE2TEUoaW5wdXQpO1xuICAgICAgICBjYXNlIFwiYXNjaWlcIjpcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVBU0NJSShpbnB1dCk7XG4gICAgICAgIGNhc2UgXCJsYXRpbjFcIjpcbiAgICAgICAgY2FzZSBcImlzby04ODU5LTFcIjpcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVMYXRpbjEoaW5wdXQpO1xuICAgICAgICBjYXNlIFwid2luZG93cy0xMjUyXCI6XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlV2luZG93czEyNTIoaW5wdXQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEVuY29kaW5nICcke2VuY29kaW5nfScgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbn1cbi8vIC0tLSBJbnRlcm5hbCBoZWxwZXJzIC0tLVxuZnVuY3Rpb24gZGVjb2RlVVRGOChieXRlcykge1xuICAgIGxldCBvdXQgPSBcIlwiO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBiMSA9IGJ5dGVzW2krK107XG4gICAgICAgIGlmIChiMSA8IDB4ODApIHtcbiAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiMSA8IDB4ZTApIHtcbiAgICAgICAgICAgIGNvbnN0IGIyID0gYnl0ZXNbaSsrXSAmIDB4M2Y7XG4gICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGIxICYgMHgxZikgPDwgNikgfCBiMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYjEgPCAweGYwKSB7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGJ5dGVzW2krK10gJiAweDNmO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBieXRlc1tpKytdICYgMHgzZjtcbiAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYjEgJiAweDBmKSA8PCAxMikgfCAoYjIgPDwgNikgfCBiMyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGJ5dGVzW2krK10gJiAweDNmO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBieXRlc1tpKytdICYgMHgzZjtcbiAgICAgICAgICAgIGNvbnN0IGI0ID0gYnl0ZXNbaSsrXSAmIDB4M2Y7XG4gICAgICAgICAgICBsZXQgY3AgPSAoKGIxICYgMHgwNykgPDwgMTgpIHxcbiAgICAgICAgICAgICAgICAoYjIgPDwgMTIpIHxcbiAgICAgICAgICAgICAgICAoYjMgPDwgNikgfFxuICAgICAgICAgICAgICAgIGI0O1xuICAgICAgICAgICAgY3AgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgwMCArICgoY3AgPj4gMTApICYgMHgzZmYpLCAweGRjMDAgKyAoY3AgJiAweDNmZikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBkZWNvZGVVVEYxNkxFKGJ5dGVzKSB7XG4gICAgbGV0IG91dCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSB8IChieXRlc1tpICsgMV0gPDwgOCkpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gZGVjb2RlQVNDSUkoYnl0ZXMpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5ieXRlcy5tYXAoKGIpID0+IGIgJiAweDdmKSk7XG59XG5mdW5jdGlvbiBkZWNvZGVMYXRpbjEoYnl0ZXMpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5ieXRlcyk7XG59XG5mdW5jdGlvbiBkZWNvZGVXaW5kb3dzMTI1MihieXRlcykge1xuICAgIGxldCBvdXQgPSBcIlwiO1xuICAgIGZvciAoY29uc3QgYiBvZiBieXRlcykge1xuICAgICAgICBpZiAoYiA+PSAweDgwICYmIGIgPD0gMHg5ZiAmJiBXSU5ET1dTXzEyNTJfRVhUUkFbYl0pIHtcbiAgICAgICAgICAgIG91dCArPSBXSU5ET1dTXzEyNTJfRVhUUkFbYl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gZW5jb2RlVVRGOChzdHIpIHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjcCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY3AgPCAweDgwKSB7XG4gICAgICAgICAgICBvdXQucHVzaChjcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3AgPCAweDgwMCkge1xuICAgICAgICAgICAgb3V0LnB1c2goMHhjMCB8IChjcCA+PiA2KSwgMHg4MCB8IChjcCAmIDB4M2YpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcCA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIG91dC5wdXNoKDB4ZTAgfCAoY3AgPj4gMTIpLCAweDgwIHwgKChjcCA+PiA2KSAmIDB4M2YpLCAweDgwIHwgKGNwICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0LnB1c2goMHhmMCB8IChjcCA+PiAxOCksIDB4ODAgfCAoKGNwID4+IDEyKSAmIDB4M2YpLCAweDgwIHwgKChjcCA+PiA2KSAmIDB4M2YpLCAweDgwIHwgKGNwICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShvdXQpO1xufVxuZnVuY3Rpb24gZW5jb2RlVVRGMTZMRShzdHIpIHtcbiAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoICogMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBvdXRbaSAqIDJdID0gY29kZSAmIDB4ZmY7XG4gICAgICAgIG91dFtpICogMiArIDFdID0gY29kZSA+PiA4O1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gZW5jb2RlQVNDSUkoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsuLi5zdHJdLm1hcCgoY2gpID0+IGNoLmNoYXJDb2RlQXQoMCkgJiAweDdmKSk7XG59XG5mdW5jdGlvbiBlbmNvZGVMYXRpbjEoc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsuLi5zdHJdLm1hcCgoY2gpID0+IGNoLmNoYXJDb2RlQXQoMCkgJiAweGZmKSk7XG59XG5mdW5jdGlvbiBlbmNvZGVXaW5kb3dzMTI1MihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWy4uLnN0cl0ubWFwKChjaCkgPT4ge1xuICAgICAgICBjb25zdCBjb2RlID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKGNvZGUgPD0gMHhmZilcbiAgICAgICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgICBpZiAoV0lORE9XU18xMjUyX1JFVkVSU0VbY2hdICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gV0lORE9XU18xMjUyX1JFVkVSU0VbY2hdO1xuICAgICAgICByZXR1cm4gMHgzZjsgLy8gJz8nXG4gICAgfSkpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@borewit/text-codec/lib/index.js\n");

/***/ })

};
;